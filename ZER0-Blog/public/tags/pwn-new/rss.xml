<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Pwn-New on ZER0-Blog</title><link>/tags/pwn-new/</link><description>Recent content in Pwn-New on ZER0-Blog</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sun, 28 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="/tags/pwn-new/rss.xml" rel="self" type="application/rss+xml"/><item><title>C++</title><link>/pwn2/new/c++/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn2/new/c++/</guid><description>std::allocator std::allocator::allocator 是 C++ 标准库中的一个类构造函数。它属于 std::allocator 类的一部分，用于分配和管理内存，特别是用于分配字符 (char) 类型的内存。 在使用 std::allocator 时，通常不需要显式调用 std::allocator::allocator 构</description></item><item><title>crt pwn</title><link>/pwn2/new/crt-pwn/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn2/new/crt-pwn/</guid><description>打NKCTF2024遇到的一个题，还比较有意思，pwn中结合了密码相关的知识 后面的内容很简单，就是写入p64()*4，因此刚好可以getsh</description></item><item><title>go</title><link>/pwn2/new/go/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn2/new/go/</guid><description>题目描述 题目的重点就是要会用go语言写一个脚本执行system函数拿到shell，题目禁用了直接调用exec函数和orw，那么可以考虑用sy</description></item><item><title>scanf的格式化字符串</title><link>/pwn2/new/scanf%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn2/new/scanf%E7%9A%84%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>做了这么久的格式化字符串，第一次见scanf的格式化字符串，于是做个记录 题目分析 可以看到把read读入的作为scanf的第一个参数，同时要注</description></item><item><title>setuid</title><link>/pwn2/new/setuid/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn2/new/setuid/</guid><description>最近做了一个题执行了system(&amp;quot;/bin/sh&amp;quot;)后发现flag只有root才有read权限，这里要提权 可以参考此篇</description></item><item><title>浮点数</title><link>/pwn2/new/%E6%B5%AE%E7%82%B9%E6%95%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn2/new/%E6%B5%AE%E7%82%B9%E6%95%B0/</guid><description>用float-toy可以很方便的构造浮点数</description></item><item><title>利用函数返回值设置rax</title><link>/pwn2/new/%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E8%AE%BE%E7%BD%AErax/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn2/new/%E5%88%A9%E7%94%A8%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E8%AE%BE%E7%BD%AErax/</guid><description>利用函数返回值设置rax参数其实是一种挺常见的技巧，read函数可以设置rax，strtol也可以设置rax 这里写的题目是vnctf2023</description></item><item><title>盲注</title><link>/pwn2/new/%E7%9B%B2%E6%B3%A8/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn2/new/%E7%9B%B2%E6%B3%A8/</guid><description>对于盲注，最关键的地方就是根据已有经验去猜 例题 SICTF ROUND3 ezsignin 题目描述，ubuntu:22.04 libc2.35 这个题通过尝试应该是个无限read+printf 解题</description></item><item><title>游戏逆向pwn</title><link>/pwn2/new/%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91pwn/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn2/new/%E6%B8%B8%E6%88%8F%E9%80%86%E5%90%91pwn/</guid><description>一个逆向游戏题,这里有个很明显的任意写漏洞 if ( op == &amp;#39;l&amp;#39; ) player_tile = getchar(); *(_BYTE *)(row[1] + buf + 90 * *row) = player_tile; 但这里有个很恶心的地方*(_BYTE *)(row[1] + buf + 90 * *row) = 0x2E; 这个地</description></item><item><title>有关system函数</title><link>/pwn2/new/%E6%9C%89%E5%85%B3system%E5%87%BD%E6%95%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn2/new/%E6%9C%89%E5%85%B3system%E5%87%BD%E6%95%B0/</guid><description>[TOC] 最近写了vnctf2023的traveler一题，一眼看出是栈迁移，题目也给了system函数，但是卡了很久 但是要注意一个很坑的地方，就是</description></item></channel></rss>