<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PWN2-Mips_pwn on ZER0-Blog</title><link>/categories/pwn2-mips_pwn/</link><description>Recent content in PWN2-Mips_pwn on ZER0-Blog</description><generator>Hugo</generator><language>zh-CN</language><lastBuildDate>Sun, 28 Jul 2024 00:00:00 +0000</lastBuildDate><atom:link href="/categories/pwn2-mips_pwn/rss.xml" rel="self" type="application/rss+xml"/><item><title>基础知识</title><link>/pwn2/mips-pwn/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn2/mips-pwn/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</guid><description>经典例题讲解 wiki内容 运行mips文件以及调试 安装mipsrop插件 shellcode base mips没有NX功能，所以栈是可以执行的，所以基本上都是打shel</description></item><item><title>例题</title><link>/pwn2/mips-pwn/%E4%BE%8B%E9%A2%98/</link><pubDate>Sun, 28 Jul 2024 00:00:00 +0000</pubDate><guid>/pwn2/mips-pwn/%E4%BE%8B%E9%A2%98/</guid><description>这里以XYCTF2024 EZ1.0? 为例题 题目分析 int vuln() { char v1[64]; // [sp+18h] [+18h] BYREF read(0, v1, 256); return 0; } 无法泄露栈地址，因此要找适当的gadget来把sp的值给某个寄存器，然</description></item></channel></rss>